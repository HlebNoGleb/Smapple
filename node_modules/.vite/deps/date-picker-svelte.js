import {
  fly
} from "./chunk-P5GKO2KF.js";
import "./chunk-X7HCJ7ZS.js";
import {
  writable
} from "./chunk-DFFOXVCY.js";
import {
  cubicInOut
} from "./chunk-VFRMSNTO.js";
import {
  SvelteComponentDev,
  add_flush_callback,
  add_location,
  add_render_callback,
  append_hydration_dev,
  append_styles,
  attr_dev,
  bind,
  binding_callbacks,
  bubble,
  check_outros,
  children,
  claim_component,
  claim_element,
  claim_space,
  claim_svg_element,
  claim_text,
  component_subscribe,
  createEventDispatcher,
  create_bidirectional_transition,
  create_component,
  destroy_component,
  destroy_each,
  detach_dev,
  dispatch_dev,
  element,
  empty,
  ensure_array_like_dev,
  group_outros,
  init,
  insert_hydration_dev,
  listen_dev,
  mount_component,
  noop,
  prop_dev,
  run_all,
  safe_not_equal,
  select_option,
  set_data_dev,
  set_input_value,
  set_style,
  space,
  svg_element,
  text,
  toggle_class,
  transition_in,
  transition_out,
  validate_slots,
  validate_store
} from "./chunk-ZPOULUBX.js";
import "./chunk-3YG4HVQA.js";
import "./chunk-ZJ46KODL.js";
import "./chunk-XNHBATJA.js";

// node_modules/date-picker-svelte/dist/date-utils.js
function isLeapYear(year) {
  return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;
}
function getMonthLength(year, month) {
  const feb = isLeapYear(year) ? 29 : 28;
  const monthLengths = [31, feb, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
  return monthLengths[month];
}
function toText(date, formatTokens) {
  let text2 = "";
  if (date) {
    for (const token of formatTokens) {
      if (typeof token === "string") {
        text2 += token;
      } else {
        text2 += token.toString(date);
      }
    }
  }
  return text2;
}
function getMonthDays(year, month) {
  const monthLength = getMonthLength(year, month);
  const days = [];
  for (let i = 0; i < monthLength; i++) {
    days.push({
      year,
      month,
      number: i + 1
    });
  }
  return days;
}
function getCalendarDays(value, weekStartsOn) {
  const year = value.getFullYear();
  const month = value.getMonth();
  const firstWeekday = new Date(year, month, 1).getDay();
  let days = [];
  const daysBefore = (firstWeekday - weekStartsOn + 7) % 7;
  if (daysBefore > 0) {
    let lastMonth = month - 1;
    let lastMonthYear = year;
    if (lastMonth === -1) {
      lastMonth = 11;
      lastMonthYear = year - 1;
    }
    days = getMonthDays(lastMonthYear, lastMonth).slice(-daysBefore);
  }
  days = days.concat(getMonthDays(year, month));
  let nextMonth = month + 1;
  let nextMonthYear = year;
  if (nextMonth === 12) {
    nextMonth = 0;
    nextMonthYear = year + 1;
  }
  const daysAfter = 42 - days.length;
  days = days.concat(getMonthDays(nextMonthYear, nextMonth).slice(0, daysAfter));
  return days;
}

// node_modules/date-picker-svelte/dist/locale.js
function getLocaleDefaults() {
  return {
    weekdays: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"],
    months: [
      "January",
      "February",
      "March",
      "April",
      "May",
      "June",
      "July",
      "August",
      "September",
      "October",
      "November",
      "December"
    ],
    weekStartsOn: 1
  };
}
function getInnerLocale(locale = {}) {
  const innerLocale = getLocaleDefaults();
  if (typeof locale.weekStartsOn === "number") {
    innerLocale.weekStartsOn = locale.weekStartsOn;
  }
  if (locale.months)
    innerLocale.months = locale.months;
  if (locale.weekdays)
    innerLocale.weekdays = locale.weekdays;
  return innerLocale;
}
function localeFromDateFnsLocale(dateFnsLocale) {
  var _a;
  const locale = getLocaleDefaults();
  if (typeof ((_a = dateFnsLocale == null ? void 0 : dateFnsLocale.options) == null ? void 0 : _a.weekStartsOn) === "number") {
    locale.weekStartsOn = dateFnsLocale.options.weekStartsOn;
  }
  if (dateFnsLocale.localize) {
    for (let i = 0; i < 7; i++) {
      locale.weekdays[i] = dateFnsLocale.localize.day(i, { width: "short" });
    }
    for (let i = 0; i < 12; i++) {
      locale.months[i] = dateFnsLocale.localize.month(i, { width: "wide" });
    }
  }
  return locale;
}

// node_modules/date-picker-svelte/dist/DatePicker.svelte
var file = "node_modules\\date-picker-svelte\\dist\\DatePicker.svelte";
function add_css(target) {
  append_styles(target, "svelte-w239uu", ".date-time-picker.svelte-w239uu.svelte-w239uu{display:inline-block;color:var(--date-picker-foreground, #000000);background:var(--date-picker-background, #ffffff);user-select:none;-webkit-user-select:none;padding:0.5rem;cursor:default;font-size:0.75rem;border:1px solid rgba(103, 113, 137, 0.3);border-radius:3px;box-shadow:0px 2px 6px rgba(0, 0, 0, 0.08), 0px 2px 6px rgba(0, 0, 0, 0.11);outline:none;transition:all 80ms cubic-bezier(0.4, 0, 0.2, 1)}.date-time-picker.svelte-w239uu.svelte-w239uu:focus{border-color:var(--date-picker-highlight-border, #0269f7);box-shadow:0px 0px 0px 2px var(--date-picker-highlight-shadow, rgba(2, 105, 247, 0.4))}.tab-container.svelte-w239uu.svelte-w239uu{outline:none}.top.svelte-w239uu.svelte-w239uu{display:flex;justify-content:center;align-items:center;padding-bottom:0.5rem}.dropdown.svelte-w239uu.svelte-w239uu{margin-left:0.25rem;margin-right:0.25rem;position:relative;display:flex}.dropdown.svelte-w239uu svg.svelte-w239uu{position:absolute;right:0px;top:0px;height:100%;width:8px;padding:0rem 0.5rem;pointer-events:none;box-sizing:content-box}.month.svelte-w239uu.svelte-w239uu{flex-grow:1}.year.svelte-w239uu.svelte-w239uu{flex-grow:1}svg.svelte-w239uu.svelte-w239uu{display:block;fill:var(--date-picker-foreground, #000000);opacity:0.75;outline:none}.page-button.svelte-w239uu.svelte-w239uu{background-color:transparent;width:1.5rem;height:1.5rem;flex-shrink:0;border-radius:5px;box-sizing:border-box;border:1px solid transparent;display:flex;align-items:center;justify-content:center}.page-button.svelte-w239uu.svelte-w239uu:hover{background-color:rgba(128, 128, 128, 0.08);border:1px solid rgba(128, 128, 128, 0.08)}.page-button.svelte-w239uu svg.svelte-w239uu{width:0.68rem;height:0.68rem}select.dummy-select.svelte-w239uu.svelte-w239uu{position:absolute;width:100%;pointer-events:none;outline:none;color:var(--date-picker-foreground, #000000);background-color:var(--date-picker-background, #ffffff);border-radius:3px}select.svelte-w239uu:focus+select.dummy-select.svelte-w239uu{border-color:var(--date-picker-highlight-border, #0269f7);box-shadow:0px 0px 0px 2px var(--date-picker-highlight-shadow, rgba(2, 105, 247, 0.4))}select.svelte-w239uu.svelte-w239uu:not(.dummy-select){opacity:0}select.svelte-w239uu.svelte-w239uu{font-size:inherit;font-family:inherit;-webkit-appearance:none;-moz-appearance:none;appearance:none;flex-grow:1;padding:0rem 0.35rem;height:1.5rem;padding-right:1.3rem;margin:0px;border:1px solid rgba(108, 120, 147, 0.3);outline:none;transition:all 80ms cubic-bezier(0.4, 0, 0.2, 1);background-image:none}.header.svelte-w239uu.svelte-w239uu{display:flex;font-weight:600;padding-bottom:2px}.header-cell.svelte-w239uu.svelte-w239uu{width:1.875rem;text-align:center;flex-grow:1}.week.svelte-w239uu.svelte-w239uu{display:flex}.cell.svelte-w239uu.svelte-w239uu{display:flex;align-items:center;justify-content:center;width:2rem;height:1.94rem;flex-grow:1;border-radius:5px;box-sizing:border-box;border:2px solid transparent}.cell.svelte-w239uu.svelte-w239uu:hover{border:1px solid rgba(128, 128, 128, 0.08)}.cell.today.svelte-w239uu.svelte-w239uu{font-weight:600;border:2px solid var(--date-picker-today-border, rgba(128, 128, 128, 0.3))}.cell.svelte-w239uu.svelte-w239uu:hover{background-color:rgba(128, 128, 128, 0.08)}.cell.disabled.svelte-w239uu.svelte-w239uu{visibility:hidden}.cell.disabled.svelte-w239uu.svelte-w239uu:hover{border:none;background-color:transparent}.cell.other-month.svelte-w239uu span.svelte-w239uu{opacity:0.4}.cell.selected.svelte-w239uu.svelte-w239uu{color:var(--date-picker-selected-color, inherit);background:var(--date-picker-selected-background, rgba(2, 105, 247, 0.2));border:2px solid var(--date-picker-highlight-border, #0269f7)}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiRGF0ZVBpY2tlci5zdmVsdGUiLCJtYXBwaW5ncyI6IkFBK1NPLDZDQUFrQixDQUN2QixPQUFPLENBQUUsWUFBWSxDQUNyQixLQUFLLENBQUUsSUFBSSx3QkFBd0IsQ0FBQyxRQUFRLENBQUMsQ0FDN0MsVUFBVSxDQUFFLElBQUksd0JBQXdCLENBQUMsUUFBUSxDQUFDLENBQ2xELFdBQVcsQ0FBRSxJQUFJLENBQ2pCLG1CQUFtQixDQUFFLElBQUksQ0FDekIsT0FBTyxDQUFFLE1BQU0sQ0FDZixNQUFNLENBQUUsT0FBTyxDQUNmLFNBQVMsQ0FBRSxPQUFPLENBQ2xCLE1BQU0sQ0FBRSxHQUFHLENBQUMsS0FBSyxDQUFDLEtBQUssR0FBRyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQzFDLGFBQWEsQ0FBRSxHQUFHLENBQ2xCLFVBQVUsQ0FBRSxHQUFHLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FDNUUsT0FBTyxDQUFFLElBQUksQ0FDYixVQUFVLENBQUUsR0FBRyxDQUFDLElBQUksQ0FBQyxhQUFhLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FDbEQsQ0FDQSw2Q0FBaUIsTUFBTyxDQUN0QixZQUFZLENBQUUsSUFBSSw4QkFBOEIsQ0FBQyxRQUFRLENBQUMsQ0FDMUQsVUFBVSxDQUFFLEdBQUcsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxJQUFJLDhCQUE4QixDQUFDLHVCQUF1QixDQUN4RixDQUVBLDBDQUFlLENBQ2IsT0FBTyxDQUFFLElBQ1gsQ0FFQSxnQ0FBSyxDQUNILE9BQU8sQ0FBRSxJQUFJLENBQ2IsZUFBZSxDQUFFLE1BQU0sQ0FDdkIsV0FBVyxDQUFFLE1BQU0sQ0FDbkIsY0FBYyxDQUFFLE1BQ2xCLENBRUEscUNBQVUsQ0FDUixXQUFXLENBQUUsT0FBTyxDQUNwQixZQUFZLENBQUUsT0FBTyxDQUNyQixRQUFRLENBQUUsUUFBUSxDQUNsQixPQUFPLENBQUUsSUFDWCxDQUNBLHVCQUFTLENBQUMsaUJBQUksQ0FDWixRQUFRLENBQUUsUUFBUSxDQUNsQixLQUFLLENBQUUsR0FBRyxDQUNWLEdBQUcsQ0FBRSxHQUFHLENBQ1IsTUFBTSxDQUFFLElBQUksQ0FDWixLQUFLLENBQUUsR0FBRyxDQUNWLE9BQU8sQ0FBRSxJQUFJLENBQUMsTUFBTSxDQUNwQixjQUFjLENBQUUsSUFBSSxDQUNwQixVQUFVLENBQUUsV0FDZCxDQUVBLGtDQUFPLENBQ0wsU0FBUyxDQUFFLENBQ2IsQ0FFQSxpQ0FBTSxDQUNKLFNBQVMsQ0FBRSxDQUNiLENBRUEsK0JBQUksQ0FDRixPQUFPLENBQUUsS0FBSyxDQUNkLElBQUksQ0FBRSxJQUFJLHdCQUF3QixDQUFDLFFBQVEsQ0FBQyxDQUM1QyxPQUFPLENBQUUsSUFBSSxDQUNiLE9BQU8sQ0FBRSxJQUNYLENBRUEsd0NBQWEsQ0FDWCxnQkFBZ0IsQ0FBRSxXQUFXLENBQzdCLEtBQUssQ0FBRSxNQUFNLENBQ2IsTUFBTSxDQUFFLE1BQU0sQ0FDZCxXQUFXLENBQUUsQ0FBQyxDQUNkLGFBQWEsQ0FBRSxHQUFHLENBQ2xCLFVBQVUsQ0FBRSxVQUFVLENBQ3RCLE1BQU0sQ0FBRSxHQUFHLENBQUMsS0FBSyxDQUFDLFdBQVcsQ0FDN0IsT0FBTyxDQUFFLElBQUksQ0FDYixXQUFXLENBQUUsTUFBTSxDQUNuQixlQUFlLENBQUUsTUFDbkIsQ0FDQSx3Q0FBWSxNQUFPLENBQ2pCLGdCQUFnQixDQUFFLEtBQUssR0FBRyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQzNDLE1BQU0sQ0FBRSxHQUFHLENBQUMsS0FBSyxDQUFDLEtBQUssR0FBRyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsSUFBSSxDQUM1QyxDQUNBLDBCQUFZLENBQUMsaUJBQUksQ0FDZixLQUFLLENBQUUsT0FBTyxDQUNkLE1BQU0sQ0FBRSxPQUNWLENBRUEsTUFBTSx5Q0FBYyxDQUNsQixRQUFRLENBQUUsUUFBUSxDQUNsQixLQUFLLENBQUUsSUFBSSxDQUNYLGNBQWMsQ0FBRSxJQUFJLENBQ3BCLE9BQU8sQ0FBRSxJQUFJLENBQ2IsS0FBSyxDQUFFLElBQUksd0JBQXdCLENBQUMsUUFBUSxDQUFDLENBQzdDLGdCQUFnQixDQUFFLElBQUksd0JBQXdCLENBQUMsUUFBUSxDQUFDLENBQ3hELGFBQWEsQ0FBRSxHQUNqQixDQUVBLG9CQUFNLE1BQU0sQ0FBRyxNQUFNLDJCQUFjLENBQ2pDLFlBQVksQ0FBRSxJQUFJLDhCQUE4QixDQUFDLFFBQVEsQ0FBQyxDQUMxRCxVQUFVLENBQUUsR0FBRyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLElBQUksOEJBQThCLENBQUMsdUJBQXVCLENBQ3hGLENBRUEsa0NBQU0sS0FBSyxhQUFhLENBQUUsQ0FDeEIsT0FBTyxDQUFFLENBQ1gsQ0FFQSxrQ0FBTyxDQUNMLFNBQVMsQ0FBRSxPQUFPLENBQ2xCLFdBQVcsQ0FBRSxPQUFPLENBQ3BCLGtCQUFrQixDQUFFLElBQUksQ0FDeEIsZUFBZSxDQUFFLElBQUksQ0FDckIsVUFBVSxDQUFFLElBQUksQ0FDaEIsU0FBUyxDQUFFLENBQUMsQ0FDWixPQUFPLENBQUUsSUFBSSxDQUFDLE9BQU8sQ0FDckIsTUFBTSxDQUFFLE1BQU0sQ0FDZCxhQUFhLENBQUUsTUFBTSxDQUNyQixNQUFNLENBQUUsR0FBRyxDQUNYLE1BQU0sQ0FBRSxHQUFHLENBQUMsS0FBSyxDQUFDLEtBQUssR0FBRyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQzFDLE9BQU8sQ0FBRSxJQUFJLENBQ2IsVUFBVSxDQUFFLEdBQUcsQ0FBQyxJQUFJLENBQUMsYUFBYSxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FDakQsZ0JBQWdCLENBQUUsSUFDcEIsQ0FFQSxtQ0FBUSxDQUNOLE9BQU8sQ0FBRSxJQUFJLENBQ2IsV0FBVyxDQUFFLEdBQUcsQ0FDaEIsY0FBYyxDQUFFLEdBQ2xCLENBRUEsd0NBQWEsQ0FDWCxLQUFLLENBQUUsUUFBUSxDQUNmLFVBQVUsQ0FBRSxNQUFNLENBQ2xCLFNBQVMsQ0FBRSxDQUNiLENBRUEsaUNBQU0sQ0FDSixPQUFPLENBQUUsSUFDWCxDQUVBLGlDQUFNLENBQ0osT0FBTyxDQUFFLElBQUksQ0FDYixXQUFXLENBQUUsTUFBTSxDQUNuQixlQUFlLENBQUUsTUFBTSxDQUN2QixLQUFLLENBQUUsSUFBSSxDQUNYLE1BQU0sQ0FBRSxPQUFPLENBQ2YsU0FBUyxDQUFFLENBQUMsQ0FDWixhQUFhLENBQUUsR0FBRyxDQUNsQixVQUFVLENBQUUsVUFBVSxDQUN0QixNQUFNLENBQUUsR0FBRyxDQUFDLEtBQUssQ0FBQyxXQUNwQixDQUNBLGlDQUFLLE1BQU8sQ0FDVixNQUFNLENBQUUsR0FBRyxDQUFDLEtBQUssQ0FBQyxLQUFLLEdBQUcsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLElBQUksQ0FDNUMsQ0FDQSxLQUFLLGtDQUFPLENBQ1YsV0FBVyxDQUFFLEdBQUcsQ0FDaEIsTUFBTSxDQUFFLEdBQUcsQ0FBQyxLQUFLLENBQUMsSUFBSSwwQkFBMEIsQ0FBQyx5QkFBeUIsQ0FDNUUsQ0FDQSxpQ0FBSyxNQUFPLENBQ1YsZ0JBQWdCLENBQUUsS0FBSyxHQUFHLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxJQUFJLENBQzVDLENBQ0EsS0FBSyxxQ0FBVSxDQUNiLFVBQVUsQ0FBRSxNQUNkLENBQ0EsS0FBSyxxQ0FBUyxNQUFPLENBQ25CLE1BQU0sQ0FBRSxJQUFJLENBQ1osZ0JBQWdCLENBQUUsV0FDcEIsQ0FDQSxLQUFLLDBCQUFZLENBQUMsa0JBQUssQ0FDckIsT0FBTyxDQUFFLEdBQ1gsQ0FDQSxLQUFLLHFDQUFVLENBQ2IsS0FBSyxDQUFFLElBQUksNEJBQTRCLENBQUMsUUFBUSxDQUFDLENBQ2pELFVBQVUsQ0FBRSxJQUFJLGlDQUFpQyxDQUFDLHVCQUF1QixDQUFDLENBQzFFLE1BQU0sQ0FBRSxHQUFHLENBQUMsS0FBSyxDQUFDLElBQUksOEJBQThCLENBQUMsUUFBUSxDQUMvRCIsIm5hbWVzIjpbXSwic291cmNlcyI6WyJEYXRlUGlja2VyLnN2ZWx0ZSJdfQ== */");
}
function get_each_context(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[29] = list[i];
  child_ctx[31] = i;
  return child_ctx;
}
function get_each_context_1(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[32] = list[i];
  return child_ctx;
}
function get_each_context_2(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[29] = list[i];
  child_ctx[36] = i;
  return child_ctx;
}
function get_each_context_3(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[37] = list[i];
  return child_ctx;
}
function get_each_context_4(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[37] = list[i];
  return child_ctx;
}
function get_each_context_5(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[42] = list[i];
  child_ctx[36] = i;
  return child_ctx;
}
function get_each_context_6(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[42] = list[i];
  child_ctx[36] = i;
  return child_ctx;
}
function create_each_block_6(ctx) {
  let option;
  let t_value = (
    /*monthName*/
    ctx[42] + ""
  );
  let t;
  let option_disabled_value;
  let option_value_value;
  const block = {
    c: function create() {
      option = element("option");
      t = text(t_value);
      this.h();
    },
    l: function claim(nodes) {
      option = claim_element(nodes, "OPTION", {});
      var option_nodes = children(option);
      t = claim_text(option_nodes, t_value);
      option_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      option.disabled = option_disabled_value = new Date(
        /*browseYear*/
        ctx[8],
        /*i*/
        ctx[36],
        getMonthLength(
          /*browseYear*/
          ctx[8],
          /*i*/
          ctx[36]
        ),
        23,
        59,
        59,
        999
      ) < /*min*/
      ctx[1] || new Date(
        /*browseYear*/
        ctx[8],
        /*i*/
        ctx[36]
      ) > /*max*/
      ctx[2];
      option.__value = option_value_value = /*i*/
      ctx[36];
      set_input_value(option, option.__value);
      add_location(option, file, 213, 12, 6209);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, option, anchor);
      append_hydration_dev(option, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*iLocale*/
      16 && t_value !== (t_value = /*monthName*/
      ctx2[42] + ""))
        set_data_dev(t, t_value);
      if (dirty[0] & /*browseYear, min, max, years*/
      294 && option_disabled_value !== (option_disabled_value = new Date(
        /*browseYear*/
        ctx2[8],
        /*i*/
        ctx2[36],
        getMonthLength(
          /*browseYear*/
          ctx2[8],
          /*i*/
          ctx2[36]
        ),
        23,
        59,
        59,
        999
      ) < /*min*/
      ctx2[1] || new Date(
        /*browseYear*/
        ctx2[8],
        /*i*/
        ctx2[36]
      ) > /*max*/
      ctx2[2])) {
        prop_dev(option, "disabled", option_disabled_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(option);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block_6.name,
    type: "each",
    source: "(213:10) {#each iLocale.months as monthName, i}",
    ctx
  });
  return block;
}
function create_each_block_5(ctx) {
  let option;
  let t_value = (
    /*monthName*/
    ctx[42] + ""
  );
  let t;
  let option_value_value;
  let option_selected_value;
  const block = {
    c: function create() {
      option = element("option");
      t = text(t_value);
      this.h();
    },
    l: function claim(nodes) {
      option = claim_element(nodes, "OPTION", {});
      var option_nodes = children(option);
      t = claim_text(option_nodes, t_value);
      option_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      option.__value = option_value_value = /*i*/
      ctx[36];
      set_input_value(option, option.__value);
      option.selected = option_selected_value = /*i*/
      ctx[36] === /*browseMonth*/
      ctx[7];
      add_location(option, file, 229, 12, 7061);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, option, anchor);
      append_hydration_dev(option, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*iLocale*/
      16 && t_value !== (t_value = /*monthName*/
      ctx2[42] + ""))
        set_data_dev(t, t_value);
      if (dirty[0] & /*browseMonth*/
      128 && option_selected_value !== (option_selected_value = /*i*/
      ctx2[36] === /*browseMonth*/
      ctx2[7])) {
        prop_dev(option, "selected", option_selected_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(option);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block_5.name,
    type: "each",
    source: "(229:10) {#each iLocale.months as monthName, i}",
    ctx
  });
  return block;
}
function create_each_block_4(ctx) {
  let option;
  let t_value = (
    /*v*/
    ctx[37] + ""
  );
  let t;
  let option_value_value;
  const block = {
    c: function create() {
      option = element("option");
      t = text(t_value);
      this.h();
    },
    l: function claim(nodes) {
      option = claim_element(nodes, "OPTION", {});
      var option_nodes = children(option);
      t = claim_text(option_nodes, t_value);
      option_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      option.__value = option_value_value = /*v*/
      ctx[37];
      set_input_value(option, option.__value);
      add_location(option, file, 243, 12, 7591);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, option, anchor);
      append_hydration_dev(option, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*years*/
      32 && t_value !== (t_value = /*v*/
      ctx2[37] + ""))
        set_data_dev(t, t_value);
      if (dirty[0] & /*years*/
      32 && option_value_value !== (option_value_value = /*v*/
      ctx2[37])) {
        prop_dev(option, "__value", option_value_value);
        set_input_value(option, option.__value);
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(option);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block_4.name,
    type: "each",
    source: "(243:10) {#each years as v}",
    ctx
  });
  return block;
}
function create_each_block_3(ctx) {
  let option;
  let t_value = (
    /*v*/
    ctx[37] + ""
  );
  let t;
  let option_value_value;
  let option_selected_value;
  const block = {
    c: function create() {
      option = element("option");
      t = text(t_value);
      this.h();
    },
    l: function claim(nodes) {
      option = claim_element(nodes, "OPTION", {});
      var option_nodes = children(option);
      t = claim_text(option_nodes, t_value);
      option_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      option.__value = option_value_value = /*v*/
      ctx[37];
      set_input_value(option, option.__value);
      option.selected = option_selected_value = /*v*/
      ctx[37] === /*browseDate*/
      ctx[3].getFullYear();
      add_location(option, file, 249, 12, 7819);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, option, anchor);
      append_hydration_dev(option, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*years*/
      32 && t_value !== (t_value = /*v*/
      ctx2[37] + ""))
        set_data_dev(t, t_value);
      if (dirty[0] & /*years*/
      32 && option_value_value !== (option_value_value = /*v*/
      ctx2[37])) {
        prop_dev(option, "__value", option_value_value);
        set_input_value(option, option.__value);
      }
      if (dirty[0] & /*years, browseDate*/
      40 && option_selected_value !== (option_selected_value = /*v*/
      ctx2[37] === /*browseDate*/
      ctx2[3].getFullYear())) {
        prop_dev(option, "selected", option_selected_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(option);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block_3.name,
    type: "each",
    source: "(249:10) {#each years as v}",
    ctx
  });
  return block;
}
function create_else_block(ctx) {
  let div;
  let t_value = (
    /*iLocale*/
    ctx[4].weekdays[
      /*iLocale*/
      ctx[4].weekStartsOn + /*i*/
      ctx[36] - 7
    ] + ""
  );
  let t;
  const block = {
    c: function create() {
      div = element("div");
      t = text(t_value);
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      t = claim_text(div_nodes, t_value);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "header-cell svelte-w239uu");
      add_location(div, file, 273, 10, 8763);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*iLocale*/
      16 && t_value !== (t_value = /*iLocale*/
      ctx2[4].weekdays[
        /*iLocale*/
        ctx2[4].weekStartsOn + /*i*/
        ctx2[36] - 7
      ] + ""))
        set_data_dev(t, t_value);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block.name,
    type: "else",
    source: "(273:8) {:else}",
    ctx
  });
  return block;
}
function create_if_block(ctx) {
  let div;
  let t_value = (
    /*iLocale*/
    ctx[4].weekdays[
      /*iLocale*/
      ctx[4].weekStartsOn + /*i*/
      ctx[36]
    ] + ""
  );
  let t;
  const block = {
    c: function create() {
      div = element("div");
      t = text(t_value);
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      t = claim_text(div_nodes, t_value);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "header-cell svelte-w239uu");
      add_location(div, file, 271, 10, 8661);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*iLocale*/
      16 && t_value !== (t_value = /*iLocale*/
      ctx2[4].weekdays[
        /*iLocale*/
        ctx2[4].weekStartsOn + /*i*/
        ctx2[36]
      ] + ""))
        set_data_dev(t, t_value);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block.name,
    type: "if",
    source: "(271:8) {#if i + iLocale.weekStartsOn < 7}",
    ctx
  });
  return block;
}
function create_each_block_2(ctx) {
  let if_block_anchor;
  function select_block_type(ctx2, dirty) {
    if (
      /*i*/
      ctx2[36] + /*iLocale*/
      ctx2[4].weekStartsOn < 7
    )
      return create_if_block;
    return create_else_block;
  }
  let current_block_type = select_block_type(ctx, [-1, -1]);
  let if_block = current_block_type(ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
    },
    p: function update(ctx2, dirty) {
      if (current_block_type === (current_block_type = select_block_type(ctx2, dirty)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if_block.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block_2.name,
    type: "each",
    source: "(270:6) {#each Array(7) as _, i}",
    ctx
  });
  return block;
}
function create_each_block_1(ctx) {
  let div;
  let span;
  let t_value = (
    /*calendarDay*/
    ctx[32].number + ""
  );
  let t;
  let mounted;
  let dispose;
  function click_handler_2() {
    return (
      /*click_handler_2*/
      ctx[23](
        /*calendarDay*/
        ctx[32]
      )
    );
  }
  const block = {
    c: function create() {
      div = element("div");
      span = element("span");
      t = text(t_value);
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      span = claim_element(div_nodes, "SPAN", { class: true });
      var span_nodes = children(span);
      t = claim_text(span_nodes, t_value);
      span_nodes.forEach(detach_dev);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(span, "class", "svelte-w239uu");
      add_location(span, file, 295, 12, 9811);
      attr_dev(div, "class", "cell svelte-w239uu");
      toggle_class(div, "disabled", !dayIsInRange(
        /*calendarDay*/
        ctx[32],
        /*min*/
        ctx[1],
        /*max*/
        ctx[2]
      ));
      toggle_class(
        div,
        "selected",
        /*value*/
        ctx[0] && /*calendarDay*/
        ctx[32].year === /*value*/
        ctx[0].getFullYear() && /*calendarDay*/
        ctx[32].month === /*value*/
        ctx[0].getMonth() && /*calendarDay*/
        ctx[32].number === /*value*/
        ctx[0].getDate()
      );
      toggle_class(
        div,
        "today",
        /*calendarDay*/
        ctx[32].year === /*todayDate*/
        ctx[9].getFullYear() && /*calendarDay*/
        ctx[32].month === /*todayDate*/
        ctx[9].getMonth() && /*calendarDay*/
        ctx[32].number === /*todayDate*/
        ctx[9].getDate()
      );
      toggle_class(
        div,
        "other-month",
        /*calendarDay*/
        ctx[32].month !== /*browseMonth*/
        ctx[7]
      );
      add_location(div, file, 282, 10, 9177);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, span);
      append_hydration_dev(span, t);
      if (!mounted) {
        dispose = listen_dev(div, "click", click_handler_2, false, false, false, false);
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty[0] & /*calendarDays*/
      64 && t_value !== (t_value = /*calendarDay*/
      ctx[32].number + ""))
        set_data_dev(t, t_value);
      if (dirty[0] & /*calendarDays, min, max*/
      70) {
        toggle_class(div, "disabled", !dayIsInRange(
          /*calendarDay*/
          ctx[32],
          /*min*/
          ctx[1],
          /*max*/
          ctx[2]
        ));
      }
      if (dirty[0] & /*value, calendarDays*/
      65) {
        toggle_class(
          div,
          "selected",
          /*value*/
          ctx[0] && /*calendarDay*/
          ctx[32].year === /*value*/
          ctx[0].getFullYear() && /*calendarDay*/
          ctx[32].month === /*value*/
          ctx[0].getMonth() && /*calendarDay*/
          ctx[32].number === /*value*/
          ctx[0].getDate()
        );
      }
      if (dirty[0] & /*calendarDays, todayDate*/
      576) {
        toggle_class(
          div,
          "today",
          /*calendarDay*/
          ctx[32].year === /*todayDate*/
          ctx[9].getFullYear() && /*calendarDay*/
          ctx[32].month === /*todayDate*/
          ctx[9].getMonth() && /*calendarDay*/
          ctx[32].number === /*todayDate*/
          ctx[9].getDate()
        );
      }
      if (dirty[0] & /*calendarDays, browseMonth*/
      192) {
        toggle_class(
          div,
          "other-month",
          /*calendarDay*/
          ctx[32].month !== /*browseMonth*/
          ctx[7]
        );
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block_1.name,
    type: "each",
    source: "(281:8) {#each calendarDays.slice(weekIndex * 7, weekIndex * 7 + 7) as calendarDay}",
    ctx
  });
  return block;
}
function create_each_block(ctx) {
  let div;
  let t;
  let each_value_1 = ensure_array_like_dev(
    /*calendarDays*/
    ctx[6].slice(
      /*weekIndex*/
      ctx[31] * 7,
      /*weekIndex*/
      ctx[31] * 7 + 7
    )
  );
  let each_blocks = [];
  for (let i = 0; i < each_value_1.length; i += 1) {
    each_blocks[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
  }
  const block = {
    c: function create() {
      div = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t = space();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(div_nodes);
      }
      t = claim_space(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "week svelte-w239uu");
      add_location(div, file, 279, 6, 8997);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div, null);
        }
      }
      append_hydration_dev(div, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*calendarDays, min, max, value, todayDate, browseMonth, selectDay*/
      4807) {
        each_value_1 = ensure_array_like_dev(
          /*calendarDays*/
          ctx2[6].slice(
            /*weekIndex*/
            ctx2[31] * 7,
            /*weekIndex*/
            ctx2[31] * 7 + 7
          )
        );
        let i;
        for (i = 0; i < each_value_1.length; i += 1) {
          const child_ctx = get_each_context_1(ctx2, each_value_1, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block_1(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(div, t);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value_1.length;
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      destroy_each(each_blocks, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block.name,
    type: "each",
    source: "(279:4) {#each Array(6) as _, weekIndex}",
    ctx
  });
  return block;
}
function create_fragment(ctx) {
  let div5;
  let div4;
  let div2;
  let button0;
  let svg0;
  let path0;
  let t0;
  let div0;
  let select0;
  let t1;
  let select1;
  let t2;
  let svg1;
  let path1;
  let t3;
  let div1;
  let select2;
  let t4;
  let select3;
  let t5;
  let svg2;
  let path2;
  let t6;
  let button1;
  let svg3;
  let path3;
  let t7;
  let div3;
  let t8;
  let mounted;
  let dispose;
  let each_value_6 = ensure_array_like_dev(
    /*iLocale*/
    ctx[4].months
  );
  let each_blocks_5 = [];
  for (let i = 0; i < each_value_6.length; i += 1) {
    each_blocks_5[i] = create_each_block_6(get_each_context_6(ctx, each_value_6, i));
  }
  let each_value_5 = ensure_array_like_dev(
    /*iLocale*/
    ctx[4].months
  );
  let each_blocks_4 = [];
  for (let i = 0; i < each_value_5.length; i += 1) {
    each_blocks_4[i] = create_each_block_5(get_each_context_5(ctx, each_value_5, i));
  }
  let each_value_4 = ensure_array_like_dev(
    /*years*/
    ctx[5]
  );
  let each_blocks_3 = [];
  for (let i = 0; i < each_value_4.length; i += 1) {
    each_blocks_3[i] = create_each_block_4(get_each_context_4(ctx, each_value_4, i));
  }
  let each_value_3 = ensure_array_like_dev(
    /*years*/
    ctx[5]
  );
  let each_blocks_2 = [];
  for (let i = 0; i < each_value_3.length; i += 1) {
    each_blocks_2[i] = create_each_block_3(get_each_context_3(ctx, each_value_3, i));
  }
  let each_value_2 = ensure_array_like_dev(Array(7));
  let each_blocks_1 = [];
  for (let i = 0; i < each_value_2.length; i += 1) {
    each_blocks_1[i] = create_each_block_2(get_each_context_2(ctx, each_value_2, i));
  }
  let each_value = ensure_array_like_dev(Array(6));
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
  }
  const block = {
    c: function create() {
      div5 = element("div");
      div4 = element("div");
      div2 = element("div");
      button0 = element("button");
      svg0 = svg_element("svg");
      path0 = svg_element("path");
      t0 = space();
      div0 = element("div");
      select0 = element("select");
      for (let i = 0; i < each_blocks_5.length; i += 1) {
        each_blocks_5[i].c();
      }
      t1 = space();
      select1 = element("select");
      for (let i = 0; i < each_blocks_4.length; i += 1) {
        each_blocks_4[i].c();
      }
      t2 = space();
      svg1 = svg_element("svg");
      path1 = svg_element("path");
      t3 = space();
      div1 = element("div");
      select2 = element("select");
      for (let i = 0; i < each_blocks_3.length; i += 1) {
        each_blocks_3[i].c();
      }
      t4 = space();
      select3 = element("select");
      for (let i = 0; i < each_blocks_2.length; i += 1) {
        each_blocks_2[i].c();
      }
      t5 = space();
      svg2 = svg_element("svg");
      path2 = svg_element("path");
      t6 = space();
      button1 = element("button");
      svg3 = svg_element("svg");
      path3 = svg_element("path");
      t7 = space();
      div3 = element("div");
      for (let i = 0; i < each_blocks_1.length; i += 1) {
        each_blocks_1[i].c();
      }
      t8 = space();
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      this.h();
    },
    l: function claim(nodes) {
      div5 = claim_element(nodes, "DIV", { class: true, tabindex: true });
      var div5_nodes = children(div5);
      div4 = claim_element(div5_nodes, "DIV", { class: true, tabindex: true });
      var div4_nodes = children(div4);
      div2 = claim_element(div4_nodes, "DIV", { class: true });
      var div2_nodes = children(div2);
      button0 = claim_element(div2_nodes, "BUTTON", { type: true, class: true, tabindex: true });
      var button0_nodes = children(button0);
      svg0 = claim_svg_element(button0_nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        viewBox: true,
        class: true
      });
      var svg0_nodes = children(svg0);
      path0 = claim_svg_element(svg0_nodes, "path", { d: true, transform: true });
      children(path0).forEach(detach_dev);
      svg0_nodes.forEach(detach_dev);
      button0_nodes.forEach(detach_dev);
      t0 = claim_space(div2_nodes);
      div0 = claim_element(div2_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      select0 = claim_element(div0_nodes, "SELECT", { class: true });
      var select0_nodes = children(select0);
      for (let i = 0; i < each_blocks_5.length; i += 1) {
        each_blocks_5[i].l(select0_nodes);
      }
      select0_nodes.forEach(detach_dev);
      t1 = claim_space(div0_nodes);
      select1 = claim_element(div0_nodes, "SELECT", { class: true, tabindex: true });
      var select1_nodes = children(select1);
      for (let i = 0; i < each_blocks_4.length; i += 1) {
        each_blocks_4[i].l(select1_nodes);
      }
      select1_nodes.forEach(detach_dev);
      t2 = claim_space(div0_nodes);
      svg1 = claim_svg_element(div0_nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        viewBox: true,
        class: true
      });
      var svg1_nodes = children(svg1);
      path1 = claim_svg_element(svg1_nodes, "path", { d: true, transform: true });
      children(path1).forEach(detach_dev);
      svg1_nodes.forEach(detach_dev);
      div0_nodes.forEach(detach_dev);
      t3 = claim_space(div2_nodes);
      div1 = claim_element(div2_nodes, "DIV", { class: true });
      var div1_nodes = children(div1);
      select2 = claim_element(div1_nodes, "SELECT", { class: true });
      var select2_nodes = children(select2);
      for (let i = 0; i < each_blocks_3.length; i += 1) {
        each_blocks_3[i].l(select2_nodes);
      }
      select2_nodes.forEach(detach_dev);
      t4 = claim_space(div1_nodes);
      select3 = claim_element(div1_nodes, "SELECT", { class: true, tabindex: true });
      var select3_nodes = children(select3);
      for (let i = 0; i < each_blocks_2.length; i += 1) {
        each_blocks_2[i].l(select3_nodes);
      }
      select3_nodes.forEach(detach_dev);
      t5 = claim_space(div1_nodes);
      svg2 = claim_svg_element(div1_nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        viewBox: true,
        class: true
      });
      var svg2_nodes = children(svg2);
      path2 = claim_svg_element(svg2_nodes, "path", { d: true, transform: true });
      children(path2).forEach(detach_dev);
      svg2_nodes.forEach(detach_dev);
      div1_nodes.forEach(detach_dev);
      t6 = claim_space(div2_nodes);
      button1 = claim_element(div2_nodes, "BUTTON", { type: true, class: true, tabindex: true });
      var button1_nodes = children(button1);
      svg3 = claim_svg_element(button1_nodes, "svg", {
        xmlns: true,
        width: true,
        height: true,
        viewBox: true,
        class: true
      });
      var svg3_nodes = children(svg3);
      path3 = claim_svg_element(svg3_nodes, "path", { d: true });
      children(path3).forEach(detach_dev);
      svg3_nodes.forEach(detach_dev);
      button1_nodes.forEach(detach_dev);
      div2_nodes.forEach(detach_dev);
      t7 = claim_space(div4_nodes);
      div3 = claim_element(div4_nodes, "DIV", { class: true });
      var div3_nodes = children(div3);
      for (let i = 0; i < each_blocks_1.length; i += 1) {
        each_blocks_1[i].l(div3_nodes);
      }
      div3_nodes.forEach(detach_dev);
      t8 = claim_space(div4_nodes);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(div4_nodes);
      }
      div4_nodes.forEach(detach_dev);
      div5_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path0, "d", "M5 3l3.057-3 11.943 12-11.943 12-3.057-3 9-9z");
      attr_dev(path0, "transform", "rotate(180, 12, 12)");
      add_location(path0, file, 200, 11, 5795);
      attr_dev(svg0, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(svg0, "width", "24");
      attr_dev(svg0, "height", "24");
      attr_dev(svg0, "viewBox", "0 0 24 24");
      attr_dev(svg0, "class", "svelte-w239uu");
      add_location(svg0, file, 199, 8, 5701);
      attr_dev(button0, "type", "button");
      attr_dev(button0, "class", "page-button svelte-w239uu");
      attr_dev(button0, "tabindex", "-1");
      add_location(button0, file, 193, 6, 5544);
      attr_dev(select0, "class", "svelte-w239uu");
      add_location(select0, file, 207, 8, 5994);
      attr_dev(select1, "class", "dummy-select svelte-w239uu");
      attr_dev(select1, "tabindex", "-1");
      add_location(select1, file, 227, 8, 6956);
      attr_dev(path1, "d", "M6 0l12 12-12 12z");
      attr_dev(path1, "transform", "rotate(90, 12, 12)");
      add_location(path1, file, 233, 11, 7267);
      attr_dev(svg1, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(svg1, "width", "24");
      attr_dev(svg1, "height", "24");
      attr_dev(svg1, "viewBox", "0 0 24 24");
      attr_dev(svg1, "class", "svelte-w239uu");
      add_location(svg1, file, 232, 8, 7173);
      attr_dev(div0, "class", "dropdown month svelte-w239uu");
      add_location(div0, file, 206, 6, 5957);
      attr_dev(select2, "class", "svelte-w239uu");
      add_location(select2, file, 237, 8, 7399);
      attr_dev(select3, "class", "dummy-select svelte-w239uu");
      attr_dev(select3, "tabindex", "-1");
      add_location(select3, file, 247, 8, 7734);
      attr_dev(path2, "d", "M6 0l12 12-12 12z");
      attr_dev(path2, "transform", "rotate(90, 12, 12)");
      add_location(path2, file, 253, 11, 8030);
      attr_dev(svg2, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(svg2, "width", "24");
      attr_dev(svg2, "height", "24");
      attr_dev(svg2, "viewBox", "0 0 24 24");
      attr_dev(svg2, "class", "svelte-w239uu");
      add_location(svg2, file, 252, 8, 7936);
      attr_dev(div1, "class", "dropdown year svelte-w239uu");
      add_location(div1, file, 236, 6, 7363);
      attr_dev(path3, "d", "M5 3l3.057-3 11.943 12-11.943 12-3.057-3 9-9z");
      add_location(path3, file, 263, 11, 8377);
      attr_dev(svg3, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(svg3, "width", "24");
      attr_dev(svg3, "height", "24");
      attr_dev(svg3, "viewBox", "0 0 24 24");
      attr_dev(svg3, "class", "svelte-w239uu");
      add_location(svg3, file, 262, 8, 8283);
      attr_dev(button1, "type", "button");
      attr_dev(button1, "class", "page-button svelte-w239uu");
      attr_dev(button1, "tabindex", "-1");
      add_location(button1, file, 256, 6, 8126);
      attr_dev(div2, "class", "top svelte-w239uu");
      add_location(div2, file, 192, 4, 5520);
      attr_dev(div3, "class", "header svelte-w239uu");
      add_location(div3, file, 267, 4, 8482);
      attr_dev(div4, "class", "tab-container svelte-w239uu");
      attr_dev(div4, "tabindex", "-1");
      add_location(div4, file, 191, 2, 5474);
      attr_dev(div5, "class", "date-time-picker svelte-w239uu");
      attr_dev(div5, "tabindex", "0");
      add_location(div5, file, 190, 0, 5395);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div5, anchor);
      append_hydration_dev(div5, div4);
      append_hydration_dev(div4, div2);
      append_hydration_dev(div2, button0);
      append_hydration_dev(button0, svg0);
      append_hydration_dev(svg0, path0);
      append_hydration_dev(div2, t0);
      append_hydration_dev(div2, div0);
      append_hydration_dev(div0, select0);
      for (let i = 0; i < each_blocks_5.length; i += 1) {
        if (each_blocks_5[i]) {
          each_blocks_5[i].m(select0, null);
        }
      }
      select_option(
        select0,
        /*browseMonth*/
        ctx[7]
      );
      append_hydration_dev(div0, t1);
      append_hydration_dev(div0, select1);
      for (let i = 0; i < each_blocks_4.length; i += 1) {
        if (each_blocks_4[i]) {
          each_blocks_4[i].m(select1, null);
        }
      }
      append_hydration_dev(div0, t2);
      append_hydration_dev(div0, svg1);
      append_hydration_dev(svg1, path1);
      append_hydration_dev(div2, t3);
      append_hydration_dev(div2, div1);
      append_hydration_dev(div1, select2);
      for (let i = 0; i < each_blocks_3.length; i += 1) {
        if (each_blocks_3[i]) {
          each_blocks_3[i].m(select2, null);
        }
      }
      select_option(
        select2,
        /*browseYear*/
        ctx[8]
      );
      append_hydration_dev(div1, t4);
      append_hydration_dev(div1, select3);
      for (let i = 0; i < each_blocks_2.length; i += 1) {
        if (each_blocks_2[i]) {
          each_blocks_2[i].m(select3, null);
        }
      }
      append_hydration_dev(div1, t5);
      append_hydration_dev(div1, svg2);
      append_hydration_dev(svg2, path2);
      append_hydration_dev(div2, t6);
      append_hydration_dev(div2, button1);
      append_hydration_dev(button1, svg3);
      append_hydration_dev(svg3, path3);
      append_hydration_dev(div4, t7);
      append_hydration_dev(div4, div3);
      for (let i = 0; i < each_blocks_1.length; i += 1) {
        if (each_blocks_1[i]) {
          each_blocks_1[i].m(div3, null);
        }
      }
      append_hydration_dev(div4, t8);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div4, null);
        }
      }
      if (!mounted) {
        dispose = [
          listen_dev(
            button0,
            "click",
            /*click_handler*/
            ctx[19],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            select0,
            "keydown",
            /*monthKeydown*/
            ctx[14],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            select0,
            "input",
            /*input_handler*/
            ctx[20],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            select2,
            "input",
            /*input_handler_1*/
            ctx[21],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            select2,
            "keydown",
            /*yearKeydown*/
            ctx[13],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            button1,
            "click",
            /*click_handler_1*/
            ctx[22],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div5,
            "focusout",
            /*focusout_handler*/
            ctx[18],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div5,
            "keydown",
            /*keydown*/
            ctx[15],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*browseYear, min, max, iLocale*/
      278) {
        each_value_6 = ensure_array_like_dev(
          /*iLocale*/
          ctx2[4].months
        );
        let i;
        for (i = 0; i < each_value_6.length; i += 1) {
          const child_ctx = get_each_context_6(ctx2, each_value_6, i);
          if (each_blocks_5[i]) {
            each_blocks_5[i].p(child_ctx, dirty);
          } else {
            each_blocks_5[i] = create_each_block_6(child_ctx);
            each_blocks_5[i].c();
            each_blocks_5[i].m(select0, null);
          }
        }
        for (; i < each_blocks_5.length; i += 1) {
          each_blocks_5[i].d(1);
        }
        each_blocks_5.length = each_value_6.length;
      }
      if (dirty[0] & /*browseMonth*/
      128) {
        select_option(
          select0,
          /*browseMonth*/
          ctx2[7]
        );
      }
      if (dirty[0] & /*browseMonth, iLocale*/
      144) {
        each_value_5 = ensure_array_like_dev(
          /*iLocale*/
          ctx2[4].months
        );
        let i;
        for (i = 0; i < each_value_5.length; i += 1) {
          const child_ctx = get_each_context_5(ctx2, each_value_5, i);
          if (each_blocks_4[i]) {
            each_blocks_4[i].p(child_ctx, dirty);
          } else {
            each_blocks_4[i] = create_each_block_5(child_ctx);
            each_blocks_4[i].c();
            each_blocks_4[i].m(select1, null);
          }
        }
        for (; i < each_blocks_4.length; i += 1) {
          each_blocks_4[i].d(1);
        }
        each_blocks_4.length = each_value_5.length;
      }
      if (dirty[0] & /*years*/
      32) {
        each_value_4 = ensure_array_like_dev(
          /*years*/
          ctx2[5]
        );
        let i;
        for (i = 0; i < each_value_4.length; i += 1) {
          const child_ctx = get_each_context_4(ctx2, each_value_4, i);
          if (each_blocks_3[i]) {
            each_blocks_3[i].p(child_ctx, dirty);
          } else {
            each_blocks_3[i] = create_each_block_4(child_ctx);
            each_blocks_3[i].c();
            each_blocks_3[i].m(select2, null);
          }
        }
        for (; i < each_blocks_3.length; i += 1) {
          each_blocks_3[i].d(1);
        }
        each_blocks_3.length = each_value_4.length;
      }
      if (dirty[0] & /*browseYear, years*/
      288) {
        select_option(
          select2,
          /*browseYear*/
          ctx2[8]
        );
      }
      if (dirty[0] & /*years, browseDate*/
      40) {
        each_value_3 = ensure_array_like_dev(
          /*years*/
          ctx2[5]
        );
        let i;
        for (i = 0; i < each_value_3.length; i += 1) {
          const child_ctx = get_each_context_3(ctx2, each_value_3, i);
          if (each_blocks_2[i]) {
            each_blocks_2[i].p(child_ctx, dirty);
          } else {
            each_blocks_2[i] = create_each_block_3(child_ctx);
            each_blocks_2[i].c();
            each_blocks_2[i].m(select3, null);
          }
        }
        for (; i < each_blocks_2.length; i += 1) {
          each_blocks_2[i].d(1);
        }
        each_blocks_2.length = each_value_3.length;
      }
      if (dirty[0] & /*iLocale*/
      16) {
        each_value_2 = ensure_array_like_dev(Array(7));
        let i;
        for (i = 0; i < each_value_2.length; i += 1) {
          const child_ctx = get_each_context_2(ctx2, each_value_2, i);
          if (each_blocks_1[i]) {
            each_blocks_1[i].p(child_ctx, dirty);
          } else {
            each_blocks_1[i] = create_each_block_2(child_ctx);
            each_blocks_1[i].c();
            each_blocks_1[i].m(div3, null);
          }
        }
        for (; i < each_blocks_1.length; i += 1) {
          each_blocks_1[i].d(1);
        }
        each_blocks_1.length = each_value_2.length;
      }
      if (dirty[0] & /*calendarDays, min, max, value, todayDate, browseMonth, selectDay*/
      4807) {
        each_value = ensure_array_like_dev(Array(6));
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(div4, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div5);
      }
      destroy_each(each_blocks_5, detaching);
      destroy_each(each_blocks_4, detaching);
      destroy_each(each_blocks_3, detaching);
      destroy_each(each_blocks_2, detaching);
      destroy_each(each_blocks_1, detaching);
      destroy_each(each_blocks, detaching);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function cloneDate(d) {
  return new Date(d.getTime());
}
function clamp(d, min2, max2) {
  if (d > max2) {
    return cloneDate(max2);
  } else if (d < min2) {
    return cloneDate(min2);
  } else {
    return cloneDate(d);
  }
}
function getYears(min2, max2) {
  let years2 = [];
  for (let i = min2.getFullYear(); i <= max2.getFullYear(); i++) {
    years2.push(i);
  }
  return years2;
}
function dayIsInRange(calendarDay, min2, max2) {
  const date = new Date(calendarDay.year, calendarDay.month, calendarDay.number);
  const minDate = new Date(min2.getFullYear(), min2.getMonth(), min2.getDate());
  const maxDate = new Date(max2.getFullYear(), max2.getMonth(), max2.getDate());
  return date >= minDate && date <= maxDate;
}
function instance($$self, $$props, $$invalidate) {
  let iLocale;
  let browseYear;
  let browseMonth;
  let calendarDays;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("DatePicker", slots, []);
  const dispatch = createEventDispatcher();
  let { value = null } = $$props;
  function setValue(d) {
    if (d.getTime() !== (value == null ? void 0 : value.getTime())) {
      $$invalidate(3, browseDate = clamp(d, min, max));
      $$invalidate(0, value = cloneDate(browseDate));
    }
  }
  function browse(d) {
    $$invalidate(3, browseDate = clamp(d, min, max));
    if (!browseWithoutSelecting && value) {
      setValue(browseDate);
    }
  }
  const todayDate = /* @__PURE__ */ new Date();
  const defaultDate = /* @__PURE__ */ new Date();
  let { min = new Date(defaultDate.getFullYear() - 20, 0, 1) } = $$props;
  let { max = new Date(defaultDate.getFullYear(), 11, 31, 23, 59, 59, 999) } = $$props;
  let browseDate = value ? cloneDate(value) : cloneDate(clamp(defaultDate, min, max));
  let years = getYears(min, max);
  let { locale = {} } = $$props;
  let { browseWithoutSelecting = false } = $$props;
  function setYear(newYear) {
    browseDate.setFullYear(newYear);
    browse(browseDate);
  }
  function setMonth(newMonth) {
    let newYear = browseDate.getFullYear();
    if (newMonth === 12) {
      newMonth = 0;
      newYear++;
    } else if (newMonth === -1) {
      newMonth = 11;
      newYear--;
    }
    const maxDate = getMonthLength(newYear, newMonth);
    const newDate = Math.min(browseDate.getDate(), maxDate);
    browse(new Date(newYear, newMonth, newDate, browseDate.getHours(), browseDate.getMinutes(), browseDate.getSeconds(), browseDate.getMilliseconds()));
  }
  function selectDay(calendarDay) {
    if (dayIsInRange(calendarDay, min, max)) {
      browseDate.setFullYear(0);
      browseDate.setMonth(0);
      browseDate.setDate(1);
      browseDate.setFullYear(calendarDay.year);
      browseDate.setMonth(calendarDay.month);
      browseDate.setDate(calendarDay.number);
      setValue(browseDate);
      dispatch("select", cloneDate(browseDate));
    }
  }
  function shiftKeydown(e) {
    if (e.shiftKey && e.key === "ArrowUp") {
      setYear(browseDate.getFullYear() - 1);
    } else if (e.shiftKey && e.key === "ArrowDown") {
      setYear(browseDate.getFullYear() + 1);
    } else if (e.shiftKey && e.key === "ArrowLeft") {
      setMonth(browseDate.getMonth() - 1);
    } else if (e.shiftKey && e.key === "ArrowRight") {
      setMonth(browseDate.getMonth() + 1);
    } else {
      return false;
    }
    e.preventDefault();
    return true;
  }
  function yearKeydown(e) {
    let shift = e.shiftKey || e.altKey;
    if (shift) {
      shiftKeydown(e);
      return;
    } else if (e.key === "ArrowUp") {
      setYear(browseDate.getFullYear() - 1);
    } else if (e.key === "ArrowDown") {
      setYear(browseDate.getFullYear() + 1);
    } else if (e.key === "ArrowLeft") {
      setMonth(browseDate.getMonth() - 1);
    } else if (e.key === "ArrowRight") {
      setMonth(browseDate.getMonth() + 1);
    } else {
      shiftKeydown(e);
      return;
    }
    e.preventDefault();
  }
  function monthKeydown(e) {
    let shift = e.shiftKey || e.altKey;
    if (shift) {
      shiftKeydown(e);
      return;
    } else if (e.key === "ArrowUp" || e.key === "ArrowLeft") {
      setMonth(browseDate.getMonth() - 1);
    } else if (e.key === "ArrowDown" || e.key === "ArrowRight") {
      setMonth(browseDate.getMonth() + 1);
    } else {
      shiftKeydown(e);
      return;
    }
    e.preventDefault();
  }
  function keydown(e) {
    var _a;
    let shift = e.shiftKey || e.altKey;
    if (((_a = e.target) == null ? void 0 : _a.tagName) === "SELECT") {
      return;
    }
    if (shift) {
      shiftKeydown(e);
      return;
    } else if (e.key === "ArrowUp") {
      browseDate.setDate(browseDate.getDate() - 7);
      setValue(browseDate);
    } else if (e.key === "ArrowDown") {
      browseDate.setDate(browseDate.getDate() + 7);
      setValue(browseDate);
    } else if (e.key === "ArrowLeft") {
      browseDate.setDate(browseDate.getDate() - 1);
      setValue(browseDate);
    } else if (e.key === "ArrowRight") {
      browseDate.setDate(browseDate.getDate() + 1);
      setValue(browseDate);
    } else if (e.key === "Enter") {
      setValue(browseDate);
      dispatch("select", cloneDate(browseDate));
    } else {
      return;
    }
    e.preventDefault();
  }
  const writable_props = ["value", "min", "max", "locale", "browseWithoutSelecting"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<DatePicker> was created with unknown prop '${key}'`);
  });
  function focusout_handler(event) {
    bubble.call(this, $$self, event);
  }
  const click_handler = () => setMonth(browseDate.getMonth() - 1);
  const input_handler = (e) => setMonth(parseInt(e.currentTarget.value));
  const input_handler_1 = (e) => setYear(parseInt(e.currentTarget.value));
  const click_handler_1 = () => setMonth(browseDate.getMonth() + 1);
  const click_handler_2 = (calendarDay) => selectDay(calendarDay);
  $$self.$$set = ($$props2) => {
    if ("value" in $$props2)
      $$invalidate(0, value = $$props2.value);
    if ("min" in $$props2)
      $$invalidate(1, min = $$props2.min);
    if ("max" in $$props2)
      $$invalidate(2, max = $$props2.max);
    if ("locale" in $$props2)
      $$invalidate(16, locale = $$props2.locale);
    if ("browseWithoutSelecting" in $$props2)
      $$invalidate(17, browseWithoutSelecting = $$props2.browseWithoutSelecting);
  };
  $$self.$capture_state = () => ({
    getMonthLength,
    getCalendarDays,
    getInnerLocale,
    createEventDispatcher,
    dispatch,
    cloneDate,
    value,
    setValue,
    browse,
    todayDate,
    defaultDate,
    min,
    max,
    clamp,
    browseDate,
    years,
    getYears,
    locale,
    browseWithoutSelecting,
    setYear,
    setMonth,
    selectDay,
    dayIsInRange,
    shiftKeydown,
    yearKeydown,
    monthKeydown,
    keydown,
    iLocale,
    calendarDays,
    browseMonth,
    browseYear
  });
  $$self.$inject_state = ($$props2) => {
    if ("value" in $$props2)
      $$invalidate(0, value = $$props2.value);
    if ("min" in $$props2)
      $$invalidate(1, min = $$props2.min);
    if ("max" in $$props2)
      $$invalidate(2, max = $$props2.max);
    if ("browseDate" in $$props2)
      $$invalidate(3, browseDate = $$props2.browseDate);
    if ("years" in $$props2)
      $$invalidate(5, years = $$props2.years);
    if ("locale" in $$props2)
      $$invalidate(16, locale = $$props2.locale);
    if ("browseWithoutSelecting" in $$props2)
      $$invalidate(17, browseWithoutSelecting = $$props2.browseWithoutSelecting);
    if ("iLocale" in $$props2)
      $$invalidate(4, iLocale = $$props2.iLocale);
    if ("calendarDays" in $$props2)
      $$invalidate(6, calendarDays = $$props2.calendarDays);
    if ("browseMonth" in $$props2)
      $$invalidate(7, browseMonth = $$props2.browseMonth);
    if ("browseYear" in $$props2)
      $$invalidate(8, browseYear = $$props2.browseYear);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*value, max, min*/
    7) {
      $:
        if (value && value > max) {
          setValue(max);
        } else if (value && value < min) {
          setValue(min);
        }
    }
    if ($$self.$$.dirty[0] & /*browseDate, value, browseWithoutSelecting*/
    131081) {
      $:
        if (browseDate.getTime() !== (value == null ? void 0 : value.getTime()) && !browseWithoutSelecting) {
          $$invalidate(3, browseDate = value ? cloneDate(value) : browseDate);
        }
    }
    if ($$self.$$.dirty[0] & /*min, max*/
    6) {
      $:
        $$invalidate(5, years = getYears(min, max));
    }
    if ($$self.$$.dirty[0] & /*locale*/
    65536) {
      $:
        $$invalidate(4, iLocale = getInnerLocale(locale));
    }
    if ($$self.$$.dirty[0] & /*browseDate*/
    8) {
      $:
        $$invalidate(8, browseYear = browseDate.getFullYear());
    }
    if ($$self.$$.dirty[0] & /*browseDate*/
    8) {
      $:
        $$invalidate(7, browseMonth = browseDate.getMonth());
    }
    if ($$self.$$.dirty[0] & /*browseDate, iLocale*/
    24) {
      $:
        $$invalidate(6, calendarDays = getCalendarDays(browseDate, iLocale.weekStartsOn));
    }
  };
  return [
    value,
    min,
    max,
    browseDate,
    iLocale,
    years,
    calendarDays,
    browseMonth,
    browseYear,
    todayDate,
    setYear,
    setMonth,
    selectDay,
    yearKeydown,
    monthKeydown,
    keydown,
    locale,
    browseWithoutSelecting,
    focusout_handler,
    click_handler,
    input_handler,
    input_handler_1,
    click_handler_1,
    click_handler_2
  ];
}
var DatePicker = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance,
      create_fragment,
      safe_not_equal,
      {
        value: 0,
        min: 1,
        max: 2,
        locale: 16,
        browseWithoutSelecting: 17
      },
      add_css,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "DatePicker",
      options,
      id: create_fragment.name
    });
  }
  get value() {
    throw new Error("<DatePicker>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<DatePicker>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get min() {
    throw new Error("<DatePicker>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set min(value) {
    throw new Error("<DatePicker>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get max() {
    throw new Error("<DatePicker>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set max(value) {
    throw new Error("<DatePicker>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get locale() {
    throw new Error("<DatePicker>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set locale(value) {
    throw new Error("<DatePicker>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get browseWithoutSelecting() {
    throw new Error("<DatePicker>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set browseWithoutSelecting(value) {
    throw new Error("<DatePicker>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var DatePicker_default = DatePicker;

// node_modules/date-picker-svelte/dist/parse.js
function parse(str, tokens, baseDate) {
  let missingPunctuation = "";
  let valid = true;
  baseDate = baseDate || new Date(2020, 0, 1, 0, 0, 0, 0);
  let year = baseDate.getFullYear();
  let month = baseDate.getMonth();
  let day = baseDate.getDate();
  let hours = baseDate.getHours();
  let minutes = baseDate.getMinutes();
  let seconds = baseDate.getSeconds();
  const ms = baseDate.getMilliseconds();
  function parseString(token) {
    for (let i = 0; i < token.length; i++) {
      if (str.startsWith(token[i])) {
        str = str.slice(1);
      } else {
        valid = false;
        if (str.length === 0)
          missingPunctuation = token.slice(i);
        return;
      }
    }
  }
  function parseUint(pattern, min, max) {
    const matches = str.match(pattern);
    if (matches == null ? void 0 : matches[0]) {
      str = str.slice(matches[0].length);
      const n = parseInt(matches[0]);
      if (n > max || n < min) {
        valid = false;
        return null;
      } else {
        return n;
      }
    } else {
      valid = false;
      return null;
    }
  }
  function parseToken(token) {
    if (typeof token === "string") {
      parseString(token);
    } else if (token.id === "yy") {
      const value = parseUint(/^[0-9]{2}/, 0, 99);
      if (value !== null)
        year = 2e3 + value;
    } else if (token.id === "yyyy") {
      const value = parseUint(/^[0-9]{4}/, 0, 9999);
      if (value !== null)
        year = value;
    } else if (token.id === "MM") {
      const value = parseUint(/^[0-9]{2}/, 1, 12);
      if (value !== null)
        month = value - 1;
    } else if (token.id === "dd") {
      const value = parseUint(/^[0-9]{2}/, 1, 31);
      if (value !== null)
        day = value;
    } else if (token.id === "HH") {
      const value = parseUint(/^[0-9]{2}/, 0, 23);
      if (value !== null)
        hours = value;
    } else if (token.id === "mm") {
      const value = parseUint(/^[0-9]{2}/, 0, 59);
      if (value !== null)
        minutes = value;
    } else if (token.id === "ss") {
      const value = parseUint(/^[0-9]{2}/, 0, 59);
      if (value !== null)
        seconds = value;
    }
  }
  for (const token of tokens) {
    parseToken(token);
    if (!valid)
      break;
  }
  const monthLength = getMonthLength(year, month);
  if (day > monthLength) {
    valid = false;
  }
  return {
    date: valid ? new Date(year, month, day, hours, minutes, seconds, ms) : null,
    missingPunctuation
  };
}
function twoDigit(value) {
  return ("0" + value.toString()).slice(-2);
}
var ruleTokens = [
  {
    id: "yyyy",
    toString: (d) => d.getFullYear().toString()
  },
  {
    id: "yy",
    toString: (d) => d.getFullYear().toString().slice(-2)
  },
  {
    id: "MM",
    toString: (d) => twoDigit(d.getMonth() + 1)
  },
  {
    id: "dd",
    toString: (d) => twoDigit(d.getDate())
  },
  {
    id: "HH",
    toString: (d) => twoDigit(d.getHours())
  },
  {
    id: "mm",
    toString: (d) => twoDigit(d.getMinutes())
  },
  {
    id: "ss",
    toString: (d) => twoDigit(d.getSeconds())
  }
];
function parseRule(s) {
  for (const token of ruleTokens) {
    if (s.startsWith(token.id)) {
      return token;
    }
  }
}
function createFormat(s) {
  const tokens = [];
  while (s.length > 0) {
    const token = parseRule(s);
    if (token) {
      tokens.push(token);
      s = s.slice(token.id.length);
    } else if (typeof tokens[tokens.length - 1] === "string") {
      tokens[tokens.length - 1] += s[0];
      s = s.slice(1);
    } else {
      tokens.push(s[0]);
      s = s.slice(1);
    }
  }
  return tokens;
}

// node_modules/date-picker-svelte/dist/DateInput.svelte
var file2 = "node_modules\\date-picker-svelte\\dist\\DateInput.svelte";
function add_css2(target) {
  append_styles(target, "svelte-1vabmef", ".date-time-field.svelte-1vabmef{position:relative}input.svelte-1vabmef{color:var(--date-picker-foreground, #000000);background:var(--date-picker-background, #ffffff);min-width:0px;box-sizing:border-box;padding:4px 6px;margin:0px;border:1px solid rgba(103, 113, 137, 0.3);border-radius:3px;width:var(--date-input-width, 150px);outline:none;transition:all 80ms cubic-bezier(0.4, 0, 0.2, 1)}input.svelte-1vabmef:focus{border-color:var(--date-picker-highlight-border, #0269f7);box-shadow:0px 0px 0px 2px var(--date-picker-highlight-shadow, rgba(2, 105, 247, 0.4))}input.svelte-1vabmef:disabled{opacity:0.5}.invalid.svelte-1vabmef{border:1px solid rgba(249, 47, 114, 0.5);background-color:rgba(249, 47, 114, 0.1)}.invalid.svelte-1vabmef:focus{border-color:#f92f72;box-shadow:0px 0px 0px 2px rgba(249, 47, 114, 0.5)}.picker.svelte-1vabmef{display:none;position:absolute;padding:1px;left:var(--picker-left-position);z-index:10}.picker.above.svelte-1vabmef{bottom:100%}.picker.visible.svelte-1vabmef{display:block}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiRGF0ZUlucHV0LnN2ZWx0ZSIsIm1hcHBpbmdzIjoiQUFnTE8sK0JBQWlCLENBQ3RCLFFBQVEsQ0FBRSxRQUNaLENBRUEsb0JBQU0sQ0FDSixLQUFLLENBQUUsSUFBSSx3QkFBd0IsQ0FBQyxRQUFRLENBQUMsQ0FDN0MsVUFBVSxDQUFFLElBQUksd0JBQXdCLENBQUMsUUFBUSxDQUFDLENBQ2xELFNBQVMsQ0FBRSxHQUFHLENBQ2QsVUFBVSxDQUFFLFVBQVUsQ0FDdEIsT0FBTyxDQUFFLEdBQUcsQ0FBQyxHQUFHLENBQ2hCLE1BQU0sQ0FBRSxHQUFHLENBQ1gsTUFBTSxDQUFFLEdBQUcsQ0FBQyxLQUFLLENBQUMsS0FBSyxHQUFHLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FDMUMsYUFBYSxDQUFFLEdBQUcsQ0FDbEIsS0FBSyxDQUFFLElBQUksa0JBQWtCLENBQUMsTUFBTSxDQUFDLENBQ3JDLE9BQU8sQ0FBRSxJQUFJLENBQ2IsVUFBVSxDQUFFLEdBQUcsQ0FBQyxJQUFJLENBQUMsYUFBYSxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQ2xELENBQ0Esb0JBQUssTUFBTyxDQUNWLFlBQVksQ0FBRSxJQUFJLDhCQUE4QixDQUFDLFFBQVEsQ0FBQyxDQUMxRCxVQUFVLENBQUUsR0FBRyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLElBQUksOEJBQThCLENBQUMsdUJBQXVCLENBQ3hGLENBQ0Esb0JBQUssU0FBVSxDQUNiLE9BQU8sQ0FBRSxHQUNYLENBRUEsdUJBQVMsQ0FDUCxNQUFNLENBQUUsR0FBRyxDQUFDLEtBQUssQ0FBQyxLQUFLLEdBQUcsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUN6QyxnQkFBZ0IsQ0FBRSxLQUFLLEdBQUcsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsQ0FDMUMsQ0FDQSx1QkFBUSxNQUFPLENBQ2IsWUFBWSxDQUFFLE9BQU8sQ0FDckIsVUFBVSxDQUFFLEdBQUcsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxLQUFLLEdBQUcsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsQ0FDcEQsQ0FFQSxzQkFBUSxDQUNOLE9BQU8sQ0FBRSxJQUFJLENBQ2IsUUFBUSxDQUFFLFFBQVEsQ0FDbEIsT0FBTyxDQUFFLEdBQUcsQ0FDWixJQUFJLENBQUUsSUFBSSxzQkFBc0IsQ0FBQyxDQUNqQyxPQUFPLENBQUUsRUFDWCxDQUNBLE9BQU8scUJBQU8sQ0FDWixNQUFNLENBQUUsSUFDVixDQUNBLE9BQU8sdUJBQVMsQ0FDZCxPQUFPLENBQUUsS0FDWCIsIm5hbWVzIjpbXSwic291cmNlcyI6WyJEYXRlSW5wdXQuc3ZlbHRlIl19 */");
}
function create_if_block2(ctx) {
  let div;
  let datetimepicker;
  let updating_value;
  let div_transition;
  let style___picker_left_position = `${/*pickerLeftPosition*/
  ctx[15]}px`;
  let current;
  function datetimepicker_value_binding(value) {
    ctx[30](value);
  }
  let datetimepicker_props = {
    min: (
      /*min*/
      ctx[3]
    ),
    max: (
      /*max*/
      ctx[4]
    ),
    locale: (
      /*locale*/
      ctx[8]
    ),
    browseWithoutSelecting: (
      /*browseWithoutSelecting*/
      ctx[9]
    )
  };
  if (
    /*$store*/
    ctx[11] !== void 0
  ) {
    datetimepicker_props.value = /*$store*/
    ctx[11];
  }
  datetimepicker = new DatePicker_default({
    props: datetimepicker_props,
    $$inline: true
  });
  binding_callbacks.push(() => bind(datetimepicker, "value", datetimepicker_value_binding));
  datetimepicker.$on(
    "focusout",
    /*onFocusOut*/
    ctx[18]
  );
  datetimepicker.$on(
    "select",
    /*onSelect*/
    ctx[20]
  );
  const block = {
    c: function create() {
      div = element("div");
      create_component(datetimepicker.$$.fragment);
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      claim_component(datetimepicker.$$.fragment, div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "picker svelte-1vabmef");
      toggle_class(
        div,
        "visible",
        /*visible*/
        ctx[2]
      );
      toggle_class(
        div,
        "above",
        /*showAbove*/
        ctx[14]
      );
      set_style(div, "--picker-left-position", style___picker_left_position);
      add_location(div, file2, 155, 4, 4594);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      mount_component(datetimepicker, div, null);
      ctx[31](div);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const datetimepicker_changes = {};
      if (dirty[0] & /*min*/
      8)
        datetimepicker_changes.min = /*min*/
        ctx2[3];
      if (dirty[0] & /*max*/
      16)
        datetimepicker_changes.max = /*max*/
        ctx2[4];
      if (dirty[0] & /*locale*/
      256)
        datetimepicker_changes.locale = /*locale*/
        ctx2[8];
      if (dirty[0] & /*browseWithoutSelecting*/
      512)
        datetimepicker_changes.browseWithoutSelecting = /*browseWithoutSelecting*/
        ctx2[9];
      if (!updating_value && dirty[0] & /*$store*/
      2048) {
        updating_value = true;
        datetimepicker_changes.value = /*$store*/
        ctx2[11];
        add_flush_callback(() => updating_value = false);
      }
      datetimepicker.$set(datetimepicker_changes);
      if (!current || dirty[0] & /*visible*/
      4) {
        toggle_class(
          div,
          "visible",
          /*visible*/
          ctx2[2]
        );
      }
      if (!current || dirty[0] & /*showAbove*/
      16384) {
        toggle_class(
          div,
          "above",
          /*showAbove*/
          ctx2[14]
        );
      }
      if (dirty[0] & /*pickerLeftPosition*/
      32768 && style___picker_left_position !== (style___picker_left_position = `${/*pickerLeftPosition*/
      ctx2[15]}px`)) {
        set_style(div, "--picker-left-position", style___picker_left_position);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(datetimepicker.$$.fragment, local);
      if (local) {
        add_render_callback(() => {
          if (!current)
            return;
          if (!div_transition)
            div_transition = create_bidirectional_transition(
              div,
              /*flyAutoPosition*/
              ctx[21],
              {},
              true
            );
          div_transition.run(1);
        });
      }
      current = true;
    },
    o: function outro(local) {
      transition_out(datetimepicker.$$.fragment, local);
      if (local) {
        if (!div_transition)
          div_transition = create_bidirectional_transition(
            div,
            /*flyAutoPosition*/
            ctx[21],
            {},
            false
          );
        div_transition.run(0);
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      destroy_component(datetimepicker);
      ctx[31](null);
      if (detaching && div_transition)
        div_transition.end();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block2.name,
    type: "if",
    source: "(155:2) {#if visible && !disabled}",
    ctx
  });
  return block;
}
function create_fragment2(ctx) {
  let div;
  let input;
  let t;
  let div_class_value;
  let current;
  let mounted;
  let dispose;
  let if_block = (
    /*visible*/
    ctx[2] && !/*disabled*/
    ctx[6] && create_if_block2(ctx)
  );
  const block = {
    c: function create() {
      div = element("div");
      input = element("input");
      t = space();
      if (if_block)
        if_block.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      input = claim_element(div_nodes, "INPUT", {
        type: true,
        placeholder: true,
        class: true
      });
      t = claim_space(div_nodes);
      if (if_block)
        if_block.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(input, "type", "text");
      input.value = /*text*/
      ctx[0];
      attr_dev(
        input,
        "placeholder",
        /*placeholder*/
        ctx[5]
      );
      input.disabled = /*disabled*/
      ctx[6];
      attr_dev(input, "class", "svelte-1vabmef");
      toggle_class(input, "invalid", !/*valid*/
      ctx[1]);
      add_location(input, file2, 128, 2, 3788);
      attr_dev(div, "class", div_class_value = "date-time-field " + /*classes*/
      ctx[7] + " svelte-1vabmef");
      add_location(div, file2, 127, 0, 3700);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, input);
      ctx[26](input);
      append_hydration_dev(div, t);
      if (if_block)
        if_block.m(div, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            input,
            "focus",
            /*focus_handler*/
            ctx[27],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "mousedown",
            /*mousedown_handler*/
            ctx[28],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input,
            "input",
            /*input_handler*/
            ctx[29],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "focusout",
            /*onFocusOut*/
            ctx[18],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "keydown",
            /*keydown*/
            ctx[19],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (!current || dirty[0] & /*text*/
      1 && input.value !== /*text*/
      ctx2[0]) {
        prop_dev(
          input,
          "value",
          /*text*/
          ctx2[0]
        );
      }
      if (!current || dirty[0] & /*placeholder*/
      32) {
        attr_dev(
          input,
          "placeholder",
          /*placeholder*/
          ctx2[5]
        );
      }
      if (!current || dirty[0] & /*disabled*/
      64) {
        prop_dev(
          input,
          "disabled",
          /*disabled*/
          ctx2[6]
        );
      }
      if (!current || dirty[0] & /*valid*/
      2) {
        toggle_class(input, "invalid", !/*valid*/
        ctx2[1]);
      }
      if (
        /*visible*/
        ctx2[2] && !/*disabled*/
        ctx2[6]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty[0] & /*visible, disabled*/
          68) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block2(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      if (!current || dirty[0] & /*classes*/
      128 && div_class_value !== (div_class_value = "date-time-field " + /*classes*/
      ctx2[7] + " svelte-1vabmef")) {
        attr_dev(div, "class", div_class_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      ctx[26](null);
      if (if_block)
        if_block.d();
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment2.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance2($$self, $$props, $$invalidate) {
  let $store;
  let $innerStore;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("DateInput", slots, []);
  const dispatch = createEventDispatcher();
  const defaultDate = /* @__PURE__ */ new Date();
  const innerStore = writable(null);
  validate_store(innerStore, "innerStore");
  component_subscribe($$self, innerStore, (value2) => $$invalidate(32, $innerStore = value2));
  const store = (() => {
    return {
      subscribe: innerStore.subscribe,
      set: (date) => {
        if (date === null || date === void 0) {
          innerStore.set(null);
          $$invalidate(22, value = date);
        } else if (date.getTime() !== ($innerStore == null ? void 0 : $innerStore.getTime())) {
          innerStore.set(date);
          $$invalidate(22, value = date);
        }
      }
    };
  })();
  validate_store(store, "store");
  component_subscribe($$self, store, (value2) => $$invalidate(11, $store = value2));
  let { value = null } = $$props;
  let { min = new Date(defaultDate.getFullYear() - 20, 0, 1) } = $$props;
  let { max = new Date(defaultDate.getFullYear(), 11, 31, 23, 59, 59, 999) } = $$props;
  let { placeholder = "2020-12-31 23:00:00" } = $$props;
  let { valid = true } = $$props;
  let { disabled = false } = $$props;
  let { class: classes = "" } = $$props;
  let { format = "yyyy-MM-dd HH:mm:ss" } = $$props;
  let formatTokens = createFormat(format);
  let { locale = {} } = $$props;
  function valueUpdate(value2, formatTokens2) {
    $$invalidate(0, text2 = toText(value2, formatTokens2));
  }
  let { text: text2 = toText($store, formatTokens) } = $$props;
  function textUpdate(text22, formatTokens2) {
    if (text22.length) {
      const result = parse(text22, formatTokens2, $store);
      if (result.date !== null) {
        $$invalidate(1, valid = true);
        store.set(result.date);
      } else {
        $$invalidate(1, valid = false);
      }
    } else {
      $$invalidate(1, valid = true);
      if (value) {
        $$invalidate(22, value = null);
        store.set(null);
      }
    }
  }
  let { visible = false } = $$props;
  let { closeOnSelection = false } = $$props;
  let { browseWithoutSelecting = false } = $$props;
  function onFocusOut(e) {
    if ((e == null ? void 0 : e.currentTarget) instanceof HTMLElement && e.relatedTarget && e.relatedTarget instanceof Node && e.currentTarget.contains(e.relatedTarget)) {
      return;
    } else {
      $$invalidate(2, visible = false);
    }
  }
  function keydown(e) {
    if (e.key === "Escape" && visible) {
      $$invalidate(2, visible = false);
      e.preventDefault();
      e.stopPropagation();
    } else if (e.key === "Enter") {
      $$invalidate(2, visible = !visible);
      e.preventDefault();
    }
  }
  function onSelect(e) {
    dispatch("select", e.detail);
    if (closeOnSelection) {
      $$invalidate(2, visible = false);
    }
  }
  let { dynamicPositioning = false } = $$props;
  let InputElement;
  let pickerElement;
  let showAbove = false;
  let pickerLeftPosition = null;
  function setDatePickerPosition() {
    $$invalidate(14, showAbove = false);
    $$invalidate(15, pickerLeftPosition = null);
    if (visible && pickerElement && dynamicPositioning) {
      const inputRect = InputElement.getBoundingClientRect();
      const horizontalOverflow = pickerElement.offsetWidth - inputRect.width;
      const bottomThreshold = inputRect.bottom + pickerElement.offsetHeight + 5;
      const rightThreshold = inputRect.left + pickerElement.offsetWidth + 5;
      if (bottomThreshold > window.innerHeight) {
        $$invalidate(14, showAbove = true);
      }
      if (rightThreshold > window.innerWidth) {
        $$invalidate(15, pickerLeftPosition = -horizontalOverflow);
        if (inputRect.left < horizontalOverflow + 5) {
          const windowCenterPos = window.innerWidth / 2;
          const newPos = windowCenterPos - pickerElement.offsetWidth / 2;
          $$invalidate(15, pickerLeftPosition = newPos - inputRect.left);
        }
      }
    }
  }
  function flyAutoPosition(node) {
    setDatePickerPosition();
    return fly(node, {
      duration: 200,
      easing: cubicInOut,
      y: showAbove ? 5 : -5
    });
  }
  const writable_props = [
    "value",
    "min",
    "max",
    "placeholder",
    "valid",
    "disabled",
    "class",
    "format",
    "locale",
    "text",
    "visible",
    "closeOnSelection",
    "browseWithoutSelecting",
    "dynamicPositioning"
  ];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<DateInput> was created with unknown prop '${key}'`);
  });
  function input_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      InputElement = $$value;
      $$invalidate(12, InputElement);
    });
  }
  const focus_handler = () => $$invalidate(2, visible = true);
  const mousedown_handler = () => $$invalidate(2, visible = true);
  const input_handler = (e) => {
    if (e instanceof InputEvent && e.inputType === "insertText" && typeof e.data === "string" && e.currentTarget.value === text2 + e.data) {
      let result = parse(text2, formatTokens, $store);
      if (result.missingPunctuation !== "" && !result.missingPunctuation.startsWith(e.data)) {
        $$invalidate(0, text2 = text2 + result.missingPunctuation + e.data);
        return;
      }
    }
    $$invalidate(0, text2 = e.currentTarget.value);
  };
  function datetimepicker_value_binding(value2) {
    $store = value2;
    store.set($store);
  }
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      pickerElement = $$value;
      $$invalidate(13, pickerElement);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("value" in $$props2)
      $$invalidate(22, value = $$props2.value);
    if ("min" in $$props2)
      $$invalidate(3, min = $$props2.min);
    if ("max" in $$props2)
      $$invalidate(4, max = $$props2.max);
    if ("placeholder" in $$props2)
      $$invalidate(5, placeholder = $$props2.placeholder);
    if ("valid" in $$props2)
      $$invalidate(1, valid = $$props2.valid);
    if ("disabled" in $$props2)
      $$invalidate(6, disabled = $$props2.disabled);
    if ("class" in $$props2)
      $$invalidate(7, classes = $$props2.class);
    if ("format" in $$props2)
      $$invalidate(23, format = $$props2.format);
    if ("locale" in $$props2)
      $$invalidate(8, locale = $$props2.locale);
    if ("text" in $$props2)
      $$invalidate(0, text2 = $$props2.text);
    if ("visible" in $$props2)
      $$invalidate(2, visible = $$props2.visible);
    if ("closeOnSelection" in $$props2)
      $$invalidate(24, closeOnSelection = $$props2.closeOnSelection);
    if ("browseWithoutSelecting" in $$props2)
      $$invalidate(9, browseWithoutSelecting = $$props2.browseWithoutSelecting);
    if ("dynamicPositioning" in $$props2)
      $$invalidate(25, dynamicPositioning = $$props2.dynamicPositioning);
  };
  $$self.$capture_state = () => ({
    fly,
    cubicInOut,
    toText,
    parse,
    createFormat,
    DateTimePicker: DatePicker_default,
    writable,
    createEventDispatcher,
    dispatch,
    defaultDate,
    innerStore,
    store,
    value,
    min,
    max,
    placeholder,
    valid,
    disabled,
    classes,
    format,
    formatTokens,
    locale,
    valueUpdate,
    text: text2,
    textUpdate,
    visible,
    closeOnSelection,
    browseWithoutSelecting,
    onFocusOut,
    keydown,
    onSelect,
    dynamicPositioning,
    InputElement,
    pickerElement,
    showAbove,
    pickerLeftPosition,
    setDatePickerPosition,
    flyAutoPosition,
    $store,
    $innerStore
  });
  $$self.$inject_state = ($$props2) => {
    if ("value" in $$props2)
      $$invalidate(22, value = $$props2.value);
    if ("min" in $$props2)
      $$invalidate(3, min = $$props2.min);
    if ("max" in $$props2)
      $$invalidate(4, max = $$props2.max);
    if ("placeholder" in $$props2)
      $$invalidate(5, placeholder = $$props2.placeholder);
    if ("valid" in $$props2)
      $$invalidate(1, valid = $$props2.valid);
    if ("disabled" in $$props2)
      $$invalidate(6, disabled = $$props2.disabled);
    if ("classes" in $$props2)
      $$invalidate(7, classes = $$props2.classes);
    if ("format" in $$props2)
      $$invalidate(23, format = $$props2.format);
    if ("formatTokens" in $$props2)
      $$invalidate(10, formatTokens = $$props2.formatTokens);
    if ("locale" in $$props2)
      $$invalidate(8, locale = $$props2.locale);
    if ("text" in $$props2)
      $$invalidate(0, text2 = $$props2.text);
    if ("visible" in $$props2)
      $$invalidate(2, visible = $$props2.visible);
    if ("closeOnSelection" in $$props2)
      $$invalidate(24, closeOnSelection = $$props2.closeOnSelection);
    if ("browseWithoutSelecting" in $$props2)
      $$invalidate(9, browseWithoutSelecting = $$props2.browseWithoutSelecting);
    if ("dynamicPositioning" in $$props2)
      $$invalidate(25, dynamicPositioning = $$props2.dynamicPositioning);
    if ("InputElement" in $$props2)
      $$invalidate(12, InputElement = $$props2.InputElement);
    if ("pickerElement" in $$props2)
      $$invalidate(13, pickerElement = $$props2.pickerElement);
    if ("showAbove" in $$props2)
      $$invalidate(14, showAbove = $$props2.showAbove);
    if ("pickerLeftPosition" in $$props2)
      $$invalidate(15, pickerLeftPosition = $$props2.pickerLeftPosition);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*value*/
    4194304) {
      $:
        store.set(value);
    }
    if ($$self.$$.dirty[0] & /*format*/
    8388608) {
      $:
        $$invalidate(10, formatTokens = createFormat(format));
    }
    if ($$self.$$.dirty[0] & /*$store, formatTokens*/
    3072) {
      $:
        valueUpdate($store, formatTokens);
    }
    if ($$self.$$.dirty[0] & /*text, formatTokens*/
    1025) {
      $:
        textUpdate(text2, formatTokens);
    }
  };
  return [
    text2,
    valid,
    visible,
    min,
    max,
    placeholder,
    disabled,
    classes,
    locale,
    browseWithoutSelecting,
    formatTokens,
    $store,
    InputElement,
    pickerElement,
    showAbove,
    pickerLeftPosition,
    innerStore,
    store,
    onFocusOut,
    keydown,
    onSelect,
    flyAutoPosition,
    value,
    format,
    closeOnSelection,
    dynamicPositioning,
    input_binding,
    focus_handler,
    mousedown_handler,
    input_handler,
    datetimepicker_value_binding,
    div_binding
  ];
}
var DateInput = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance2,
      create_fragment2,
      safe_not_equal,
      {
        value: 22,
        min: 3,
        max: 4,
        placeholder: 5,
        valid: 1,
        disabled: 6,
        class: 7,
        format: 23,
        locale: 8,
        text: 0,
        visible: 2,
        closeOnSelection: 24,
        browseWithoutSelecting: 9,
        dynamicPositioning: 25
      },
      add_css2,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "DateInput",
      options,
      id: create_fragment2.name
    });
  }
  get value() {
    throw new Error("<DateInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<DateInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get min() {
    throw new Error("<DateInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set min(value) {
    throw new Error("<DateInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get max() {
    throw new Error("<DateInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set max(value) {
    throw new Error("<DateInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get placeholder() {
    throw new Error("<DateInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set placeholder(value) {
    throw new Error("<DateInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get valid() {
    throw new Error("<DateInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set valid(value) {
    throw new Error("<DateInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<DateInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<DateInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<DateInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<DateInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get format() {
    throw new Error("<DateInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set format(value) {
    throw new Error("<DateInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get locale() {
    throw new Error("<DateInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set locale(value) {
    throw new Error("<DateInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get text() {
    throw new Error("<DateInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set text(value) {
    throw new Error("<DateInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get visible() {
    throw new Error("<DateInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set visible(value) {
    throw new Error("<DateInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get closeOnSelection() {
    throw new Error("<DateInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set closeOnSelection(value) {
    throw new Error("<DateInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get browseWithoutSelecting() {
    throw new Error("<DateInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set browseWithoutSelecting(value) {
    throw new Error("<DateInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get dynamicPositioning() {
    throw new Error("<DateInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set dynamicPositioning(value) {
    throw new Error("<DateInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var DateInput_default = DateInput;
export {
  DateInput_default as DateInput,
  DatePicker_default as DatePicker,
  localeFromDateFnsLocale
};
//# sourceMappingURL=date-picker-svelte.js.map
